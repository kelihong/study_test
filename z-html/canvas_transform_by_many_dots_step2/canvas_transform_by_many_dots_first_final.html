<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        img {
            width: 600px;
            height: 600px;
            background: rgb(255, 220, 145);
        }
        
        .point-item {
            position: absolute;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-size: 12px;
            color: #fff;
            background: crimson;
            opacity: 0.4;
            border-radius: 50%;
            /* pointer-events: none; */
            cursor: pointer;
            transform: translate(-50%, -50%);
            z-index: 99;
        }
        
        canvas {
            width: 600px;
            height: 600px;
            /* border: 1px solid grey; */
            background: rgba(196, 196, 196, 0.133);
            position: absolute;
            left: calc(50% - 300px);
            top: 130px;
        }
        
        #canvas {
            opacity: 0.3;
            z-index: 5;
        }
        
        #canvasBg {
            z-index: 3;
        }
        
        #input {
            display: block;
            width: 98%;
            height: auto;
            min-height: 30px;
            margin: 0 auto;
            font-size: 12px;
            text-align: center;
            pointer-events: none;
        }
        
        .tool-list {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .tool-item {
            display: inline-block;
            cursor: pointer;
            margin-right: 10px;
            position: relative;
            overflow: hidden;
            padding: 1px;
        }
        
        .tool-item.no-event {
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .tool-item .tool-btn {
            background-color: rgb(255, 187, 0);
            padding: 3px 10px;
            color: #fff;
            border-radius: 5px;
        }
        
        .tool-item:active .tool-btn {
            opacity: .3;
        }
        
        .tool-item:hover .tool-btn {
            opacity: .7;
        }
        
        .tool-item .file-input {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            opacity: 0;
        }
        
        .tool-item .tool-value {
            display: block;
            min-width: 600px;
            color: #333;
            background: #ccc;
            padding: 2px 5px;
            text-align: center;
        }
        
        .desc-list {
            color: #999;
        }
        
        .desc-item {
            display: inline-block;
        }
    </style>
</head>

<body>
    <div class="tool-list">
        <div class="tool-item">
            <span id="resetBtn" class="tool-btn bg-red">重置</span>

        </div>
        <div class="tool-item">
            <span class="tool-btn">添加背景</span>
            <input class="file-input" id="bgInput" type="file">
        </div>
        <div class="tool-item">
            <span class="tool-btn">添加花纹</span>
            <input class="file-input" id="textureInput" type="file" accept="image/png, image/jpeg,image/svg">
        </div>
        <div class="tool-item">
            <span class="tool-btn" id="copyBtn">复制</span>
        </div>

    </div>
    <canvas id="canvas" width="600" height="600"></canvas>
    <canvas id="canvasBg" width="600" height="600"></canvas>
    <!-- <img id="img" src="" alt=""> -->
    <input id="input" contenteditable="true" />
    <div class="point-item">左上</div>
    <div class="point-item">右上</div>
    <div class="point-item">右下</div>
    <div class="point-item">左下</div>
    <div class="point-item">上中</div>
    <div class="point-item">右中</div>
    <div class="point-item">下中</div>
    <div class="point-item">左中</div>
    <script src="/static/js/jquery-3.5.1.js"></script>
    <script>
        // let src = '/static/images/my.png'
        let src = '/static/images/test23.png'
            // let src = '/static/images/no_data.png'
        let img = document.getElementById('img')
        let canvas = document.getElementById('canvas')
        let canvasBg = document.getElementById('canvasBg')
            // let canvas = document.createElement('canvas')
        let textureInput = document.getElementById('textureInput')

        let resetBtn = document.getElementById('resetBtn')
        let copyBtn = document.getElementById('copyBtn')
        let bgInput = document.getElementById('bgInput')
            // document.body.appendChild(canvas)
        let input = document.getElementById('input')


        // 添加背景图片
        bgInput.onclick = function() {
            this.value = ''
        }

        // 重置：
        resetBtn.onclick = function() {
            window.location.reload()
        }

        // 设置添加背景：
        bgInput.onchange = function(e) {

            let file = this.files[0]
            console.log(file)

            let reader = new FileReader()
            reader.readAsDataURL(file)
            reader.onload = function(e) {
                let ctxBg = canvasBg.getContext('2d')
                let bgImg = new Image()
                bgImg.src = this.result
                bgImg.onload = function() {
                    ctxBg.drawImage(bgImg, 0, 0, canvasBg.width, canvasBg.height)
                }

            }

        }

        // 添加花纹
        textureInput.onclick = function() {
            this.value = ''
        }

        textureInput.onchange = function(e) {

            let file = this.files[0]
            console.log(file)

            let reader = new FileReader()
            reader.readAsDataURL(file)
            reader.onload = function(e) {
                src = this.result
                transform2d({
                    imgUrl: src,
                    options: newP
                }).then(res => {
                    // img.src = res
                    // console.log(2)
                })

            }

        }




        let newP = [{
            "x": 0,
            "y": 0
        }, {
            "x": 600,
            "y": 0
        }, {
            "x": 600,
            "y": 600
        }, {
            "x": 0,
            "y": 600
        }, {
            "x": 300,
            "y": 0
        }, {
            "x": 600,
            "y": 300
        }, {
            "x": 300,
            "y": 600
        }, {
            "x": 0,
            "y": 300
        }]


        // 复制：
        copyBtn.onclick = function() {
            $('#input').select()
            document.execCommand("Copy");
            showMsg({
                type: 'success',
                msg: '已复制！'
            })
        }

        setPointItems()

        // 获取鼠标移动的位置
        function getArea(e) {
            e = e || window.event;
            return {
                l: e.clientX - canvas.offsetLeft + document.body.scrollLeft + document.documentElement.scrollLeft,
                t: e.clientY - canvas.offsetTop + document.body.scrollTop + document.documentElement.scrollTop,
            };
        }

        // 当可能超边界：f
        function doWhenNearOut(e) {
            if (e.clientY <= 1) {
                canvas.style.marginTop = canvasBg.offsetTop + 1 + 'px'
                canvasBg.style.marginTop = canvasBg.offsetTop + 1 + 'px'

                newP.forEach(item => {
                    item.y += 1
                })

            }
            if (e.clientX <= 1) {
                canvas.style.marginLeft = canvas.offsetTop + 1 + 'px'
                canvasBg.style.marginLeft = canvasBg.offsetTop + 1 + 'px'

                newP.forEach(item => {
                    item.x += 1
                })

            }

            setPointItems()

        }

        // 设置四个点位置：
        function setPointItems() {
            let points = $('.point-item')
            let finalP = []

            newP.forEach((item, index) => {
                points.eq(index).css({
                    left: item.x + canvas.offsetLeft,
                    top: item.y + canvas.offsetTop
                })
                finalP.push({
                    x: item.x * 2,
                    y: item.y * 2
                })
            })

            input.value = JSON.stringify(finalP)
        }

        // 可拉伸区域
        let resizableSize = 30 // 不能大于canvas最短边的一半
        let area = null,
            curDot = null,
            index = undefined
        window.addEventListener('mousedown', down, false)

        // 鼠标按下
        function down(e) {
            e.preventDefault()
            if (!e.target.classList.contains('point-item') && e.target.tagName !== "CANVAS") {
                return
            }

            // 获取鼠标点击坐标：
            area = getArea(e)




            for (let i = 0; i < newP.length; i++) {

                curDot = newP[i]
                nextDot = newP[0]
                if (area.t > curDot.y - resizableSize && area.t < curDot.y + resizableSize && area.l > curDot.x - resizableSize && area.l < curDot.x + resizableSize) {
                    index = i
                    break
                } else {
                    curDot = null
                }
            }



            window.addEventListener('mousemove', move, false)
            window.addEventListener('mouseup', up, false)
        }

        // 鼠标移动
        function move(e) {

            doWhenNearOut(e)

            e.preventDefault();
            let narea = getArea(e);
            let nx = narea.l - area.l;
            let ny = narea.t - area.t;
            area = narea;



            if (!curDot) {
                return
            }

            curDot.x += nx
            curDot.y += ny



            setPointItems()
                // transform2d({

            // })
            transform2d({
                imgUrl: src,
                options: newP
            }).then(res => {

            })

        }

        // 鼠标抬起
        function up(e) {
            transform2d({
                imgUrl: src,
                options: newP
            }).then(res => {

            })


            window.removeEventListener('mousemove', move, false)
            window.removeEventListener('mouseup', up, false)
        }




        // transform2d({
        //     imgUrl: src,
        //     options: newP
        // }).then(res => {
        //     // img.src = res
        //     // console.log(2)
        // })


        function transform2d({
            imgUrl = '',
            options = [{
                    "x": 0,
                    "y": 0
                }, {
                    "x": 600,
                    "y": 0
                }, {
                    "x": 600,
                    "y": 600
                }, {
                    "x": 0,
                    "y": 600
                }, {
                    "x": 300,
                    "y": 0
                }, {
                    "x": 600,
                    "y": 500
                }, {
                    "x": 300,
                    "y": 600
                }, {
                    "x": 0,
                    "y": 300
                }

            ],
            canvasSize = {
                width: 600,
                height: 600
            }
        }) {

            let defaultParams = [{
                    x: 0,
                    y: 0
                }, {
                    x: canvasSize.width,
                    y: 0
                }, {
                    x: canvasSize.width,
                    y: canvasSize.height
                }, {
                    x: 0,
                    y: canvasSize.height
                }, {
                    x: canvasSize.width / 2,
                    y: 0
                }, {
                    x: canvasSize.width,
                    y: canvasSize.height / 2
                }, {
                    x: canvasSize.width / 2,
                    y: canvasSize.height
                }, {
                    x: 0,
                    y: canvasSize.height / 2
                },

            ]
            canvas.setAttribute('width', canvasSize.width)
            canvas.setAttribute('height', canvasSize.height)
            let ctx = canvas.getContext('2d')
            let img = new Image()
            let sp = 4
            img.src = imgUrl
            return new Promise((resolve => {
                img.onload = function() {

                    let newOp = getMeshPoints(options)


                    // 新的三角形
                    let newRectainArr = getPoint(newOp)


                    // 旧的三角形
                    let oldRectainArr = getPoint(getMeshPoints(defaultParams))

                    // 合成最后的图形
                    for (let i = 0; i < newRectainArr.length; i++) {
                        drawTriangle(ctx, img, newRectainArr[i], oldRectainArr[i])
                    }

                    let url = canvas.toDataURL('image/png')
                    resolve(url)

                }
            }))

            // 画每一个三角形
            function drawTriangle(ctx, img, pre, nxt) {
                let s = 0.3

                // 设置偏移量画两遍，解决缝隙问题
                drawTexturedTriangle(ctx, img, pre[0].x, pre[0].y + s, pre[1].x + s, pre[1].y + s, pre[2].x + s, pre[2].y + s, nxt[0].x + s, nxt[0].y + s, nxt[1].x + s, nxt[1].y + s, nxt[2].x + s, nxt[2].y + s)
                drawTexturedTriangle(ctx, img, pre[0].x, pre[0].y, pre[1].x, pre[1].y, pre[2].x, pre[2].y, nxt[0].x, nxt[0].y, nxt[1].x, nxt[1].y, nxt[2].x, nxt[2].y)

            }


            // 获取每个三角形的点坐标数组
            function getPoint(matrixArr) {

                let dotsDatas = []

                for (let i = 0; i < matrixArr.length - 1; i++) {

                    for (let j = 0; j < matrixArr[i].length - 1; j++) {
                        let item1 = matrixArr[i][j]
                        let item2 = matrixArr[i][j + 1]
                        let item3 = matrixArr[i + 1][j + 1]
                        let item4 = matrixArr[i + 1][j]
                        dotsDatas.push([item1, item2, item4])
                        dotsDatas.push([item2, item3, item4])
                    }
                }
                return dotsDatas

            }



            // 画三角形
            function drawTexturedTriangle(ctx, img, x0, y0, x1, y1, x2, y2,
                u0, v0, u1, v1, u2, v2) {

                ctx.beginPath();
                // ctx.moveTo(x0, y0);
                // ctx.lineTo(x1, y1);
                // ctx.lineTo(x2, y2);
                // 为了去掉缝隙
                ctx.moveTo(x0, y0 - 1);
                ctx.lineTo(x1 + 1, y1 + 1);
                ctx.lineTo(x2 - 1, y2 + 1);

                ctx.closePath();

                x1 -= x0;
                y1 -= y0;
                x2 -= x0;
                y2 -= y0;

                u1 -= u0;
                v1 -= v0;
                u2 -= u0;
                v2 -= v0;

                var det = 1 / (u1 * v2 - u2 * v1),

                    // linear transformation
                    a = (v2 * x1 - v1 * x2) * det,
                    b = (v2 * y1 - v1 * y2) * det,
                    c = (u1 * x2 - u2 * x1) * det,
                    d = (u1 * y2 - u2 * y1) * det,

                    // translation
                    e = x0 - a * u0 - c * v0,
                    f = y0 - b * u0 - d * v0;

                ctx.save();
                ctx.transform(a, b, c, d, e, f);

                ctx.clip();
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                ctx.restore();



                return ctx
            }

            // 获取每个点的坐标
            function getMeshPoints(param) {


                let m1 = param[0]
                let m2 = param[1]
                let m3 = param[2]
                let m4 = param[3]
                let c1 = param[4]
                let c2 = param[5]
                let c3 = param[6]
                let c4 = param[7]
                    // 算横中间那个交点
                let c5 = crossoverPoint(
                    [c3, c1], [c2, c4]
                )

                // 计算每行、每列每个店的坐标：
                // 算出最上排
                let mtt = subLinePoints(m1, m2, c1)
                    // 算最下排
                let mtb = subLinePoints(m4, m3, c3)
                    // 算右边：
                let mtr = subLinePoints(m2, m3, c2)
                    // 算左边：
                let mtl = subLinePoints(m1, m4, c4)
                    // 算出中间两条线上点坐标：
                    // 垂直中间那条
                let mch = subLinePoints(c1, c3, c5)
                    // 水平中间那条
                let mcv = subLinePoints(c4, c2, c5)



                // 此处要计算顶部和底部的曲线哦！
                let half = sp / 2
                    // 把他们分割成四个小方块

                let s1 = [mtt[0], mtt[half], c5, mcv[0]]
                let s2 = [mtt[half], mtt[sp], mcv[sp], c5]
                let s3 = [mtl[half], c5, mtb[half], mtb[0]]
                let s4 = [c5, mtr[half], mtb[sp], mtb[half]]

                // 每个四分之一方形的二分数组：
                let v1 = setSinglePartList(s1)
                let v2 = setSinglePartList(s2)
                let v3 = setSinglePartList(s3)
                let v4 = setSinglePartList(s4)

                let nv = []
                for (let j = 0; j < v1.length - 1; j++) {
                    v1[j].splice(-1, 1)

                    nv.push(v1[j].concat(v2[j]))
                }
                for (let j = 0; j < v3.length; j++) {
                    v3[j].splice(-1, 1)

                    nv.push(v3[j].concat(v4[j]))
                }

                return nv

            }

            function setSinglePartList(s) {
                let t1 = s[0]
                let t2 = s[1]
                let t3 = s[2]
                let t4 = s[3]
                let msp = sp / 2
                stt = singleLinePoints(t1, t2, msp)
                stb = singleLinePoints(t4, t3, msp)
                stl = singleLinePoints(t1, t4, msp)
                str = singleLinePoints(t2, t3, msp)
                    // 算剩下的排，并合起来变成数组
                let finalArr = [stt]
                    // 算出中间：
                for (let i = 1; i < msp; i++) {
                    let item = singleLinePoints(stl[i], str[i], msp)
                    finalArr.push(item)
                }
                finalArr.push(stb)

                return finalArr // 算剩下的排，并合起来变成数组


                // return {
                //     stt,
                //     stb,
                //     stl,
                //     str
                // }

            }


            // 获取单行（单列）的坐标
            function singleLinePoints(m1, m2, msp) {
                if (!msp) {
                    msp = sp
                }
                let mt = []
                let mtX = (m2.x - m1.x) / msp
                let mtY = (m2.y - m1.y) / msp

                for (let i = 0; i <= msp; i++) {
                    mt.push({
                        x: m1.x + mtX * i,
                        y: m1.y + mtY * i
                    })
                }
                return mt
            }
            // 获取单行（单列）的坐标
            function singleLineHalfPoints(m1, m2) {
                let mt = []
                let mtX = (m2.x - m1.x) / (sp / 2)
                let mtY = (m2.y - m1.y) / (sp / 2)

                for (let i = 0; i <= sp / 2; i++) {
                    mt.push({
                        x: m1.x + mtX * i,
                        y: m1.y + mtY * i
                    })
                }
                return mt
            }

            function subLinePoints(mt_1, mt_2, mt_c) {
                // 算出最上排
                let mtt1 = singleLineHalfPoints(mt_1, mt_c)
                let mtt2 = singleLineHalfPoints(mt_c, mt_2)
                mtt1.splice(-1, 1)
                return mtt1.concat(mtt2)
            }


        }

        // 直线方程：
        function lineEquation(param1, param2) {
            let k, b;

            k = (param2.y - param1.y) / (param2.x - param1.x)
            b = param1.y - k * param1.x

            return {
                k,
                b
            }
        }

        // 输入四个点(两条直线分别的两个点，求交点）
        function crossoverPoint(
            line1Data,
            line2Data
        ) {
            let lineres1 = lineEquation(line1Data[0], line1Data[1])
            let lineres2 = lineEquation(line2Data[0], line2Data[1])

            let k1 = lineres1.k
            let b1 = lineres1.b
            let k2 = lineres2.k
            let b2 = lineres2.b

            let x, y;

            // ------ 很重要的地方 start （！！！记得判断斜率！！！）---------
            // 判断斜率是否不存在：
            // (如果斜率不存在，则判断那个坐标相减等于零，横坐标相减等于零，则 x=x1为直线方程)
            if (line1Data[0].x - line1Data[1].x === 0) {
                x = line1Data[0].x
                y = k2 * x + b2

            } else if (line2Data[0].x - line2Data[1].x === 0) {
                x = line2Data[0].x
                y = k1 * x + b1
            } else {
                x = (b1 - b2) / (k2 - k1)
                y = k1 * x + b1
            }
            // ------ 很重要的地方 end ---------

            return {
                x,
                y
            }


        }

        // 弹窗
        function showMsg(param) {
            let params = {
                msg: '',
                type: ''
            }
            if (typeof param === 'string') {
                params.msg = param
            } else {
                params = param
            }
            let msgBox = document.getElementById('kbbMsgBox')

            if (msgBox) {
                msgBox.remove()
            }
            let div = document.createElement('div')
            div.id = 'kbbMsgBox'
            div.style.position = 'fixed'
            div.style.top = 300 + 'px'
            div.style.left = '50%'
            div.style.transform = 'translateX(-50%)'
            div.style.backgroundColor = '#8c8c8c'
            div.style.color = '#fff'
            div.style.borderRadius = '8px'
            div.style.padding = '5px 15px'
            div.style.zIndex = 19999
            div.innerHTML = params.msg || ''

            if (params.type === 'success') {
                div.style.backgroundColor = '#4CAF50'
            } else if (params.type === 'error') {
                div.style.backgroundColor = '#d61313'
            } else if (params.type === 'warning') {
                div.style.backgroundColor = 'rgb(231 144 32)'
            } else {
                div.style.backgroundColor = '#8c8c8c'
            }
            document.body.appendChild(div)
            setTimeout(() => {
                div.remove()
            }, 2000);
        }
    </script>
</body>

</html>